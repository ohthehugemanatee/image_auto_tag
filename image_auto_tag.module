<?php
declare(strict_types = 1);
/**
 * @file
 * Procedural code for image_auto_tag module.
 */

use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\image_auto_tag\AzureCognitiveServices;
use Drupal\image_auto_tag\Entity\PersonMap;
use GuzzleHttp\Exception\TransferException;

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Add a setting for face detection on image fields.
 */
function image_auto_tag_form_field_config_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  /** @var \Drupal\field\FieldConfigInterface $entity */
  $entity = $form_state->getFormObject()->getEntity();
  if ($entity->getFieldStorageDefinition()->getType() === 'image') {
    $form['third_party_settings']['image_auto_tag']['detect_faces'] = [
      '#type' => 'checkbox',
      '#title' => t('Detect faces in uploaded images'),
      '#description' => t('Submit images for face detection using Image Auto Tag module.'),
      '#default_value' => $entity->getThirdPartySetting('image_auto_tag', 'detect_faces'),
    ];
    // If the module isn't configured yet.
    if (\Drupal::config('image_auto_tag.settings')->get('person_entity_bundle') === NULL) {
      $form['third_party_settings']['image_auto_tag']['detect_faces'] = [
        '#description' => t('Submit images for face detection using Image Auto Tag module.  You must configure the module before you can use it!'),
        '#disabled' => TRUE,
      ] + $form['third_party_settings']['image_auto_tag']['detect_faces'];
      return;
    }
    // Build a list of entity reference fields pointing to the right type.
    $tagFieldOptions = [];
    // Look up "the right type" in config.
    $targetEntityBundleString = \Drupal::config('image_auto_tag.settings')->get('person_entity_bundle');
    list($targetEntityType, $targetEntityBundle) = explode('.', $targetEntityBundleString);
    $fieldInstances = \Drupal::service('entity_field.manager')->getFieldDefinitions($entity->getTargetEntityTypeId(), $entity->getTargetBundle());
    foreach ($fieldInstances as $fieldName => $fieldInstance) {
      // If it's an entity reference pointing at the right type.
      if ($fieldInstance->getType() === 'entity_reference' && $fieldInstance->getSettings()['target_type'] === $targetEntityType) {
        $tagFieldOptions[$fieldName] = $fieldName;
      }
    }
    if ($tagFieldOptions === []) {
      $form['third_party_settings']['image_auto_tag']['detect_faces'] = [
        '#description' => t('Submit images for face detection using Image Auto Tag module.  No entity reference field found on this bundle, which references the "people" type defined in settings. Please check your settings for image_auto_tag and try again.'),
        '#disabled' => TRUE,
      ] + $form['third_party_settings']['image_auto_tag']['detect_faces'];
    }
    else {
      $form['third_party_settings']['image_auto_tag']['tag_field'] = [
        '#title' => t('Tag field'),
        '#description' => t('The field which will receive tags based on face recognition. Manual entries into this field will be overwritten when detection is performed!'),
        '#type' => 'select',
        '#options' => $tagFieldOptions,
        '#default_value' => $entity->getThirdPartySetting('image_auto_tag', 'tag_field'),
        '#states' => [
          'visible' => [
            ':input[name="third_party_settings[image_auto_tag][detect_faces]"]' => ['checked' => TRUE],
          ],
        ],
      ];
    }
  }
}

/**
 * Implements hook_entity_presave().
 */
function image_auto_tag_entity_presave(EntityInterface $entity) {
  if (!($entity instanceof ContentEntityInterface) || $entity instanceof PersonMap) {
    return;
  }
  // If the entity has a field that should have face detection performed, submit
  // images and tag.
  foreach ($entity->getFieldDefinitions() as $fieldDefinition) {
    $fieldName = $fieldDefinition->getName();
    // If this in an image field, with 'detect_faces'=TRUE, and this is either
    // a new entity, or an updated field value.
    if ($fieldDefinition->getType() === 'image' &&
      $fieldDefinition->getThirdPartySetting('image_auto_tag', 'detect_faces') &&
      (!isset($entity->original) || $entity->get($fieldName)->entity->id() !== $entity->original->get($fieldName)->entity->id())
    ) {
      // If this should be processed asynchronously, queue it and return.
      if (\Drupal::config('image_auto_tag.settings')->get('synchronous_mode') === FALSE) {
        // Queue processing for later.
        /** @var \Drupal\Core\Queue\QueueFactory $queue_factory */
        $queue_factory = \Drupal::service('queue');
        /** @var \Drupal\Core\Queue\QueueInterface $queue */
        $queue = $queue_factory->get('image_auto_tag_detect_faces');
        $item = [
          'entityId' => $entity->id(),
          'entityType' => $entity->getEntityTypeId(),
          'fieldName' => $fieldName,
        ];
        $queue->createItem($item);
        return;
      }
      // The Image Auto Tag service.
      $imageAutoTag = \Drupal::service('image_auto_tag');
      $peopleEntities = $imageAutoTag->detectAndIdentifyFaces($entity, $fieldDefinition);
      if (!empty($peopleEntities)) {
        // Apply this as the target field value.
        $targetTagField = $fieldDefinition->getThirdPartySetting('image_auto_tag', 'tag_field');
        $entity->set($targetTagField, $peopleEntities);
      }
      $count = count($peopleEntities);
      \Drupal::messenger()->addStatus("Detected {$count} faces.");
    }
  }
}

/**
 * Implements hook_entity_insert().
 */
function image_auto_tag_entity_insert(EntityInterface $entity) {
  _image_auto_tag_entity_post_save($entity);
}

/**
 * Implements hook_entity_update().
 */
function image_auto_tag_entity_update(EntityInterface $entity) {
  _image_auto_tag_entity_post_save($entity);
}

/**
 * Entity insert and update hook.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity that has just been saved.
 *
 * @throws \Drupal\Core\Entity\EntityStorageException
 * @throws \Drupal\Core\TypedData\Exception\MissingDataException
 * @throws \GuzzleHttp\Exception\GuzzleException
 */
function _image_auto_tag_entity_post_save(EntityInterface $entity) {
  if (!($entity instanceof ContentEntityInterface)) {
    return;
  }
  $config = \Drupal::config('image_auto_tag.settings');
  // Check entity type and bundle.
  $targetEntityBundleString = $config->get('person_entity_bundle');
  list($targetEntityType, $targetEntityBundle) = explode('.', $targetEntityBundleString);
  // If the entity is our "people" entity, check faces.
  if ($entity->getEntityTypeId() === $targetEntityType && $entity->bundle() === $targetEntityBundle) {
    // If this should be processed asynchronously, queue it and return.
    if (\Drupal::config('image_auto_tag.settings')->get('synchronous_mode') === FALSE) {
      // Queue processing for later.
      /** @var \Drupal\Core\Queue\QueueFactory $queue_factory */
      $queue_factory = \Drupal::service('queue');
      /** @var \Drupal\Core\Queue\QueueInterface $queue */
      $queue = $queue_factory->get('image_auto_tag_process_person');
      $item = [
        'entityId' => $entity->id(),
        'entityType' => $entity->getEntityTypeId(),
      ];
      $queue->createItem($item);
      return;
    }
    // Image Auto Tag service.
    /** @var \Drupal\image_auto_tag\ImageAutoTag $imageAutoTag */
    $imageAutoTag = \Drupal::service('image_auto_tag');
    // Do we have a person record yet?
    $personMapResult = \Drupal::entityQuery('image_auto_tag_person_map')
      ->condition('local_id', $entity->id())
      ->condition('local_entity_type', $entity->getEntityTypeId())
      ->execute();
    // If we don't have a record, create one on Azure.
    if ($personMapResult === []) {
      $imageAutoTag->createPerson($entity);
      $imageAutoTag->createFaces($entity);
    }
    else {
      /** @var \Drupal\image_auto_tag\Entity\PersonMap[] $personMaps */
      $personMaps = PersonMap::loadMultiple($personMapResult);
      $personMap = reset($personMaps);
      // Otherwise, update the existing Person on Azure.
      if ($entity->label() !== $entity->original->label()) {
        // @todo: Do this through the generic ImageAutoTag service.
        $azure = \Drupal::service('image_auto_tag.azure');
        $azure->updatePerson(AzureCognitiveServices::PEOPLE_GROUP, $personMap->getForeignId(), $entity->label());
      }
      // If the faces image field value has changed.
      $targetImageField = explode('.', $config->get('person_image_field'))[1];
      $imageFilesArray = $entity->get($targetImageField)->getValue();
      if ($imageFilesArray !== $entity->original->get($targetImageField)->getValue()) {
        // Make sure all the local images exist on the remote.
        foreach ($imageFilesArray as $index => $value) {
          /** @var \Drupal\Core\Image\Image $image */
          $image = $entity->get($targetImageField)->get($index);
          $personMapResult = \Drupal::entityQuery('image_auto_tag_person_map')
            ->condition('local_id', $image->entity->id())
            ->condition('local_entity_type', 'file')
            ->execute();
          // If this image doesn't have a personMap yet, upload it as a face.
          if ($personMapResult === []) {
            try {
              $imagePath = $image->entity->getFileUri();
              $faceId = $azure->addFace(AzureCognitiveServices::PEOPLE_GROUP, $personMap->getForeignId(), $imagePath);
              PersonMap::create([
                'foreign_id' => $faceId->persistedFaceId,
                'local_id' => $image->entity->id(),
                'local_entity_type' => 'file',
              ])->save();
            }
            catch (TransferException $e) {
              \Drupal::messenger()->addWarning(t('Unable to submit face images to Azure for processing. Error: %code : %msg.',
                [
                  '%code' => $e->getCode(),
                  '%msg' => $e->getMessage(),
                ]
              ));
            }
          }
        }
        // Delete any remote images that aren't on local.
        $personRecord = $azure->getPerson(AzureCognitiveServices::PEOPLE_GROUP, $personMap->getForeignId());
        $faceIds = $personRecord->persistedFaceIds;
        $personMapResult = \Drupal::entityQuery('image_auto_tag_person_map')
          ->condition('foreign_id', $faceIds, 'IN')
          ->condition('local_entity_type', 'file')
          ->execute();
        if (count($personMapResult) !== count($faceIds)) {
          $personMaps = PersonMap::loadMultiple($personMapResult);
          $foreignIds = [];
          foreach ($personMaps as $personMap) {
            $foreignIds[] = $personMap->getForeignId();
          }
          $missingFaces = array_diff($foreignIds, $faceIds);
          // Delete any faces that exist on foreign, but not local.
          foreach ($missingFaces as $missingFace) {
            $azure->deleteFace(AzureCognitiveServices::PEOPLE_GROUP, $personMap->getForeignId(), $missingFace);
          }
        }
      }
    }
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Clean up when a mapped entity is deleted.
 */
function image_auto_tag_entity_delete(EntityInterface $entity) {
  if ($entity instanceof ContentEntityInterface) {
    // If this should be processed asynchronously, queue it and return.
    if (\Drupal::config('image_auto_tag.settings')->get('synchronous_mode') === FALSE) {
      // Queue processing for later.
      /** @var \Drupal\Core\Queue\QueueFactory $queue_factory */
      $queue_factory = \Drupal::service('queue');
      /** @var \Drupal\Core\Queue\QueueInterface $queue */
      $queue = $queue_factory->get('image_auto_tag_deleted_entity');
      $item = [
        'entityId' => $entity->id(),
        'entityType' => $entity->getEntityTypeId(),
      ];
      $queue->createItem($item);
      return;
    }
    $personMapResult = \Drupal::entityQuery('image_auto_tag_person_map')
      ->condition('local_id', $entity->id())
      ->condition('local_entity_type', $entity->getEntityTypeId())
      ->execute();
    if ($personMapResult > 0) {
      /** @var \Drupal\image_auto_tag\Entity\PersonMap $personMaps */
      $personMaps = PersonMap::loadMultiple($personMapResult);
      foreach ($personMaps as $personMap) {
        // @todo: implement this.
        $personMap->delete();
      }
    }
  }
}
